// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: outbounds.query.sql

package outbounds

import (
	"context"
)

const createOutbound = `-- name: CreateOutbound :exec
INSERT INTO outbounds (item_id, order_id, qty)
VALUES ($1, $2, $3)
`

type CreateOutboundParams struct {
	ItemID  int32 `json:"item_id"`
	OrderID int32 `json:"order_id"`
	Qty     int32 `json:"qty"`
}

func (q *Queries) CreateOutbound(ctx context.Context, arg CreateOutboundParams) error {
	_, err := q.db.ExecContext(ctx, createOutbound, arg.ItemID, arg.OrderID, arg.Qty)
	return err
}

const getOutbound = `-- name: GetOutbound :one
SELECT id, item_id, order_id, qty FROM outbounds WHERE id = $1
`

func (q *Queries) GetOutbound(ctx context.Context, id int32) (Outbound, error) {
	row := q.db.QueryRowContext(ctx, getOutbound, id)
	var i Outbound
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.OrderID,
		&i.Qty,
	)
	return i, err
}

const getOutbounds = `-- name: GetOutbounds :many
SELECT id, item_id, order_id, qty FROM outbounds limit 50
`

func (q *Queries) GetOutbounds(ctx context.Context) ([]Outbound, error) {
	rows, err := q.db.QueryContext(ctx, getOutbounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Outbound
	for rows.Next() {
		var i Outbound
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.OrderID,
			&i.Qty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
